# How to Read and Interpret a Security Scan

16, December 2020 â€¢ [jayala-29](https://github.com/jayala-29)

---

## What is a security scan?

When developing an application, whether it's mobile or web, it's important to keep security in mind for ensuring the safety of potential users. Running a security scan on source files is a simple yet effective way of making sure secure code practices are being followed and that there are little to no holes for attackers to take advantage of. 

A static security scan provides insight to what permissions are being used, if activities are being exported, checking for hard-coded passwords and most importantly, revealing common vulnerabilities and how they can be fixed. In reality, it's difficult to solve every security-related problem because software developers tend to be focused on pushing releases out and write a ton of code; however, it's always important to keep up-to-date with modern attacks and resolve issues when they do come up.

## What is being used for treehouses?

Because security is important, static security scans are being run every time a release is published in [treehouses remote](https://github.com/treehouses/remote/releases)

This is done via the security tool: MobSF, otherwise known as Mobile Security Framework. Taken directly from the [Github page](https://github.com/MobSF/Mobile-Security-Framework-MobSF):

Mobile Security Framework (MobSF) is an automated, all-in-one mobile application (Android/iOS/Windows) pen-testing, malware analysis and security assessment framework capable of performing static and dynamic analysis. MobSF support mobile app binaries (APK, IPA & APPX) along with zipped source code and provides REST APIs for seamless integration with your CI/CD or DevSecOps pipeline.

MobSF is a neat tool because it can quickly analyze source code and provide useful feedback about an application. In this blog, we will take a high-level approach to debriefing the most important sections of the report generated by MobSF. In the case of treehouses, a security scan is run on the APK that you see published to the app store. Let's dive into an example that comes from the latest release at the moment of publication.

## Example Situation

The scan that we will use for the purpose of this blog can be found [here](https://github.com/treehouses/remote/releases/download/v6042/6042-security-scan.pdf)

After downloading the PDF of the security scan with version 6042, please have it side-by-side as you are reading through what's to follow:

### The Front Page

This page contains basic information about the APK that was run through MobSF. We can see the file name, package name, average CVSS score, app security score, and scan date. The package name is how the APK is stored on the Android device, this can be useful when using ADB for debugging or trying to grab information about the logs generated during usage. 

The Common Vulnerability Scoring System (CVSS) provides software developers, testers, and security and IT professionals with a standardized process for assessing vulnerabilities. You can use the CVSS to assess the threat level of each vulnerability, and then prioritize mitigation accordingly. With 10 being the most vulnerable (aka, the easiest application to attack). You can read more about how it works [here](https://blog.malwarebytes.com/malwarebytes-news/2020/05/how-cvss-works-characterizing-and-scoring-vulnerabilities/)

The App Security Score should not be taken heavily, here we see a 0/100. This score starts at 100, and deducts a certain amount for each vulnerable component found. More details of calculations can be found on the last page of the report. You may be thinking that this is really really bad; however, most of the time, deductions come from false-positives. We'll talk about this more in the Application Permissions section, so no need to freak out :)

### Certificate Information

Certificates for devices validate identities to make sure only authorized users, messages, or other types of servers have access to the device. Every time an app is deployed, it needs to be signed by the developer(s).

In the table, we can see that the "Application is signed with a code signing certificate" - which is awesome.

When we look below that entry, we have a "bad" status because the "Application is signed with v1 signature scheme, making it vulnerable to Janus vulnerability on Android <7.0." In this case, we can relay back to the developers that the application needs to be also signed with a v2 signature scheme because v1 is outdated. How to do this can be read more about [here](https://source.android.com/security/apksigning)

### Application Permissions

The way to approach this section is to always keep the following in mind: What is the purpose of each permission? Are they necessary to the application's functionality?

If the answer is yes, then simply ignore the severity and move on. No need to panic over a dangerous android.permission.ACCESS_FINE_LOCATION if it's necessary to collect data for **dogi**, or android.permission.BLUETOOTH if it's necessary for pairing with the Raspberri Pi.

However, you might want to bring up if android.permission.WRITE_SETTINGS is necessary for the application to function. Because if not, we can see the potential attack in the description shown: Malicious applications can
corrupt your system's configuration.

### Manifest and Code Analyses

So this is the part where points get deducted from the Security Score mentioned above. In addition, these sections can be the ones to provide the most insight to developers about what the application uses.

Take for example the entry under Manifest Analysis: is it necessary to have cleartext traffic enabled? If so, don't worry about it and feel free to add them points back to the Security Score. If not, then a simple fix for this can be to set this flag set to false (as mentioned in the DESCRIPTION). Talk to **dogi** and the developers about this, they'll provide insight :)

Moving on to the Code Analysis section, let's pick out one or two entries from here and see what we could debunk.

Scroll to Entry 7: The App uses an insecure Random Number Generator. Because the code is nicely obfuscated (hidden) after decompilation, it may be difficult to pinpoint exactly where a random number generator is being used in the original source code. This is an opportunity to reach out and ask: is it crucial for the application to use a very secure random generator, or is it used in a not so important component of the app? The answer to this question will either allow you to move on from this entry or lead to the developers updating the generator so that no sensitive/critical data is compromised.

Scroll to Entry 9: App uses SQLite Database and execute raw SQL query. Here we can clearly see where the SQLite database is being used within the parse directory java files. A tool like [Drozer](https://github.com/fsecurelabs/drozer/) can be used to try to tamper with and modify the database associated with the treehouses app for penetration testing purposes. Otherwise, reach out to the developers about this to see if any filters are in place when the app user enters text into this particular field that communicates directly with SQLite. 

### Hardcoded Secrets

Scroll to Page  17 of the report. This can be a potential danger, reach out to **dogi** and the developers to see if they can locate this information in the original source code using `grep` and find a way to secure these secrets if they are crucial to the application. Security through obscurity is a booboo, any secrets stored in "hidden" parts of the source code can easily be located by an attacker and exploited...

## Congrats! You just read through and interpreted a once tedious static scan report :)
